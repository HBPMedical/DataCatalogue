"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const logger_symbols_1 = require("./logger/logger-symbols");
const flatten_array_1 = require("./utilities/flatten-array");
class AngularPackageOrchestrator {
    static orchestrateAngularPackagesBuild(angularPackages) {
        const angularPackageBuilds = this.findBuildOrderForAngularPackagesWithSubPackages(angularPackages);
        const angularPackageAndSubPackageBuilds = angularPackageBuilds.map((angularPackagesOrdered) => {
            return angularPackagesOrdered.map((angularPackageOrdered) => {
                return this.findBuildOrderForAngularPackages(angularPackageOrdered);
            });
        });
        return angularPackageAndSubPackageBuilds;
    }
    static findBuildOrderForAngularPackagesWithSubPackages(angularPackages) {
        const angularPackageNames = angularPackages
            .map((angularPackages) => {
            return angularPackages[0].packageName;
        });
        let angularPackagesNotYetInBuilds = angularPackages;
        const angularPackageNamesAlreadyInBuilds = [];
        const builds = [];
        while (angularPackagesNotYetInBuilds.length !== 0) {
            const angularPackagesForNextBuild = [];
            angularPackagesNotYetInBuilds = angularPackagesNotYetInBuilds
                .filter((angularPackage) => {
                const angularPackageDependenciesNotYetInBuilds = Object
                    .keys(angularPackage[0].dependencies)
                    .filter((dependency) => {
                    return angularPackageNames.indexOf(dependency) !== -1;
                })
                    .filter((dependency) => {
                    return angularPackageNamesAlreadyInBuilds.indexOf(dependency) === -1;
                });
                if (angularPackageDependenciesNotYetInBuilds.length === 0) {
                    angularPackagesForNextBuild.push(angularPackage);
                    return false;
                }
                else {
                    return true;
                }
            });
            if (angularPackagesForNextBuild.length === 0) {
                this.handleAngularPackagesWithSubPackagesCircularDependencyError(angularPackagesNotYetInBuilds);
            }
            builds.push(angularPackagesForNextBuild);
            const angularPackageNamesForNextBuild = angularPackagesForNextBuild
                .map((angularPackageReadyForBuild) => {
                return angularPackageReadyForBuild[0].packageName;
            });
            angularPackageNamesAlreadyInBuilds.push(...angularPackageNamesForNextBuild);
        }
        return builds;
    }
    static findBuildOrderForAngularPackages(angularPackages) {
        const angularPackageNames = angularPackages
            .map((angularPackages) => {
            return angularPackages.packageName;
        });
        let angularPackagesNotYetInBuilds = angularPackages;
        const externalImportSourcesAlreadyInBuilds = [];
        const builds = [];
        while (angularPackagesNotYetInBuilds.length !== 0) {
            const angularPackagesForNextBuild = [];
            angularPackagesNotYetInBuilds = angularPackagesNotYetInBuilds
                .filter((angularPackage) => {
                const externalImportSourcesNotYetInBuilds = angularPackage.externalImportSources
                    .filter((externalImportSource) => {
                    return angularPackageNames.indexOf(externalImportSource) !== -1;
                })
                    .filter((externalImportSource) => {
                    return externalImportSourcesAlreadyInBuilds.indexOf(externalImportSource) === -1;
                });
                if (externalImportSourcesNotYetInBuilds.length === 0) {
                    angularPackagesForNextBuild.push(angularPackage);
                    return false;
                }
                else {
                    return true;
                }
            });
            if (angularPackagesForNextBuild.length === 0) {
                this.handleAngularPackageCircularDependencyError(angularPackagesNotYetInBuilds);
            }
            builds.push(angularPackagesForNextBuild);
            const packageNamesReadyForBuild = angularPackagesForNextBuild
                .map((angularPackageReadyForBuild) => {
                return angularPackageReadyForBuild.packageName;
            });
            externalImportSourcesAlreadyInBuilds.push(...packageNamesReadyForBuild);
        }
        return builds;
    }
    static handleAngularPackagesWithSubPackagesCircularDependencyError(angularPackages) {
        const angularPackagesWithCircularDependencies = angularPackages
            .map((angularPackage) => {
            return angularPackage[0];
        });
        const angularPackageNames = angularPackagesWithCircularDependencies
            .map((angularPackage) => {
            return angularPackage.packageName;
        });
        const errorDetails = flatten_array_1.flattenArray(angularPackagesWithCircularDependencies
            .map((angularPackage) => {
            return [
                `Package "${angularPackage.packageName}"`,
                ...Object.keys(angularPackage.dependencies)
                    .filter((dependency) => {
                    return angularPackageNames.indexOf(dependency) !== -1;
                })
                    .map((dependency) => {
                    return `  ${logger_symbols_1.loggerSymbols.arrow} depends on "${dependency}"`;
                })
            ];
        }));
        const errorMessage = [
            'An error occured while starting the build.',
            '',
            'Message:    Circular dependencies between differetn packages detected.',
            '',
            'Caused by:  Angular Package Builder',
            ...errorDetails
                .map((errorLine, index) => {
                return index === 0
                    ? `Details:    ${errorLine}`
                    : `            ${errorLine}`;
            }),
            '',
            'Tip: Verify that all dependencies are defined correctly, and remove any circular dependencies between them.',
            '',
            ''
        ].join('\n');
        throw new Error(errorMessage);
    }
    static handleAngularPackageCircularDependencyError(angularPackages) {
        const angularPackageNames = angularPackages
            .map((angularPackage) => {
            return angularPackage.packageName;
        });
        const errorDetails = flatten_array_1.flattenArray(angularPackages
            .map((angularPackage) => {
            return [
                `Package "${angularPackage.packageName}"`,
                ...angularPackage.externalImportSources
                    .filter((dependency) => {
                    return angularPackageNames.indexOf(dependency) !== -1;
                })
                    .map((dependency) => {
                    return `  ${logger_symbols_1.loggerSymbols.arrow} depends on "${dependency}"`;
                })
            ];
        }));
        const errorMessage = [
            'An error occured while starting the build.',
            '',
            'Message:    Circular dependencies within the same package detected.',
            '',
            'Caused by:  Angular Package Builder',
            ...errorDetails
                .map((errorLine, index) => {
                return index === 0
                    ? `Details:    ${errorLine}`
                    : `            ${errorLine}`;
            }),
            '',
            'Tip: Remove any circular dependencies between the primary / all secondary entry packages.',
            '',
            ''
        ].join('\n');
        throw new Error(errorMessage);
    }
}
exports.AngularPackageOrchestrator = AngularPackageOrchestrator;
//# sourceMappingURL=angular-package-orchestrator.js.map