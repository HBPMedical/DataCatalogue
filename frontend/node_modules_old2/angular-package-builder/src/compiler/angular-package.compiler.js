"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const del = require("del");
const semver_1 = require("semver");
const main_1 = require("@angular/compiler-cli/src/main");
const write_file_1 = require("../utilities/write-file");
const typescript_configuration_builder_1 = require("./typescript-configuration-builder");
const get_installed_dependency_version_1 = require("../utilities/get-installed-dependency-version");
const copy_files_1 = require("../utilities/copy-files");
const angular_package_logger_1 = require("../logger/angular-package-logger");
class AngularPackageCompiler {
    constructor(angularPackage) {
        this.angularPackage = angularPackage;
    }
    compile(target) {
        return __awaiter(this, void 0, void 0, function* () {
            const tsconfig = yield this.buildTypescriptConfiguration(target);
            const tsconfigPath = path_1.posix.join(this.angularPackage.root, this.angularPackage.outDir, 'temp', `tsconfig.${target}.json`);
            yield write_file_1.writeFile(tsconfigPath, tsconfig);
            const angularCompilerCliArguments = yield this.getAngularCompilerCliArguments(tsconfigPath);
            yield main_1.main(angularCompilerCliArguments, (error) => {
                this.handleAngularCompilerCliError(error, tsconfig.compilerOptions.target);
            });
            const buildFilesPattern = '*.+(js?(.map)|d.ts|json)';
            yield copy_files_1.copyFiles(path_1.posix.join(this.angularPackage.root, this.angularPackage.outDir, 'temp', 'transformed', '**', buildFilesPattern), path_1.posix.join(this.angularPackage.root, this.angularPackage.outDir, 'temp', target));
            yield del([
                path_1.posix.join(this.angularPackage.root, this.angularPackage.outDir, 'temp', 'transformed', '**', buildFilesPattern)
            ]);
        });
    }
    buildTypescriptConfiguration(target) {
        return __awaiter(this, void 0, void 0, function* () {
            const tempDir = path_1.posix.join(this.angularPackage.root, this.angularPackage.outDir, 'temp');
            const entryDir = path_1.posix.join(tempDir, 'transformed');
            const outDir = path_1.posix.join(tempDir, 'transformed');
            const entryFile = path_1.posix.join(tempDir, 'transformed', path_1.posix.basename(this.angularPackage.entryFile));
            return new typescript_configuration_builder_1.TypeScriptConfigurationBuilder()
                .setEntry(entryFile, entryDir)
                .setOutDir(outDir)
                .setPackageName(this.angularPackage.packageName)
                .setCompilationTarget(target)
                .setCustomTypescriptCompilerOptions(this.angularPackage.typescriptCompilerOptions)
                .setCustomAngularCompilerOptions(this.angularPackage.angularCompilerOptions)
                .build();
        });
    }
    getAngularCompilerCliArguments(tsconfigPath) {
        return __awaiter(this, void 0, void 0, function* () {
            const angularCompilerCliVersion = yield get_installed_dependency_version_1.getInstalledDependencyVersion('@angular/compiler-cli');
            const angularCompilerCliArguments = semver_1.gte(angularCompilerCliVersion, '5.0.0')
                ? ['-p', tsconfigPath]
                : { p: tsconfigPath };
            return angularCompilerCliArguments;
        });
    }
    handleAngularCompilerCliError(error, target) {
        let details;
        switch (true) {
            case /(error|warning) TS0/.test(error):
                details = this.constructTypescriptErrorDetails(error, 'tsickle');
                break;
            case /(error|warning) TS[0-9]+/.test(error):
                details = this.constructTypescriptErrorDetails(error, 'TypeScript');
                break;
            case /compiler-cli/.test(error):
                details = this.constructAngularCompilerErrorDetails(error, 'Angular Compiler');
                break;
            default:
                details = error;
                break;
        }
        const errorMessage = [
            `An error occured while compiling the sources to ${target}.`,
            '',
            details,
            '',
            'Tip: For known pitfalls, also see https://github.com/dominique-mueller/angular-package-builder#known-pitfalls-with-solutions'
        ].join('\n');
        angular_package_logger_1.AngularPackageLogger.logMessage(errorMessage, 'error');
        throw new Error(errorMessage);
    }
    constructTypescriptErrorDetails(error, origin) {
        const sourceFile = error
            .split(':')[0]
            .replace(/^transformed/, '.')
            .split('(').join(' (')
            .replace(',', ':');
        const errorCode = error
            .split(':')[1]
            .trim();
        const errorMessage = error
            .split(':')[2]
            .trim()
            .replace(/\.$/, '');
        return [
            `Message:    ${errorMessage[0].toUpperCase()}${errorMessage.slice(1)}`,
            '',
            `Caused by:  ${origin}`,
            `Code:       ${errorCode[0].toUpperCase()}${errorCode.slice(1)}`,
            `File:       ${sourceFile} [to be compiled]`
        ].join('\n');
    }
    constructAngularCompilerErrorDetails(error, origin) {
        const errorLines = error
            .replace(/^: Error: /, '')
            .split('\n')
            .filter((errorLine) => {
            return !errorLine.trim().startsWith('at');
        })
            .map((errorLine) => {
            return errorLine.trim();
        });
        const basePath = path_1.posix.join(this.angularPackage.root, this.angularPackage.outDir, 'temp', 'transformed');
        const sourceFile = errorLines
            .reverse()
            .find((errorLine) => {
            return new RegExp(`^${basePath}`, 'g').test(errorLine);
        })
            .split(' ')[0]
            .replace(new RegExp(basePath, 'g'), '.')
            .replace(/:(\d+):(\d+):/, ' ($1:$2)');
        const errorMessages = errorLines
            .reverse()
            .map((errorLine) => {
            return new RegExp(`^${basePath}`, 'g').test(errorLine)
                ? errorLine.split(' ').slice(1).join(' ')
                : errorLine;
        });
        const errorMessage = errorMessages
            .filter((errorLine) => {
            return errorLine[0] !== '{';
        })
            .filter((errorLine) => {
            return errorLine.trim() !== '';
        })
            .map((errorLine, index) => {
            return index === 0
                ? `Message:    ${errorLine}`
                : `            ${errorLine}`;
        });
        const errorDetails = JSON.stringify(JSON.parse(errorMessages
            .find((errorLine) => {
            return errorLine[0] === '{';
        })), null, '  ')
            .split('\n')
            .map((objectLine, index) => {
            return index === 0
                ? `Details:    ${objectLine}`
                : `            ${objectLine}`;
        });
        return [
            ...errorMessage,
            '',
            `Caused by:  ${origin} [to be compiled]`,
            `File:       ${sourceFile}`,
            ...errorDetails
        ].join('\n');
    }
}
exports.AngularPackageCompiler = AngularPackageCompiler;
//# sourceMappingURL=angular-package.compiler.js.map